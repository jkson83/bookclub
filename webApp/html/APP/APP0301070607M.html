<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no, maximum-scale=1, user-scalable=0">
  <title>에브리북클럽</title>
  <link rel="stylesheet" href="../../resources/css/app/ui.ebook.css">
  <script type="text/javascript" src="../_ui_include/app_head.js"></script><!-- //Include: head -->
</head>
<body>
  <!-- 23.12.04 wrap-game 클래스 추가 -->
  <div id="wrap" class="wrap wrap-game game3">
    <div class="question-top">
      <div class="q-sticker-area">
        <span class="icon-sticker on">스티커</span>
        <span class="icon-sticker on">스티커</span>
        <span class="icon-sticker">스티커</span>
      </div>

      <div class="q-descript-area">
        <p class="q-descript">뜻에 알맞은 낱말을 이어 만들어 주세요.</p>

        <button type="button" class="descript-sound">지시문 듣기</button>
      </div>

      <button class="btn-end">종료</button>
    </div> 

    <!-- 질문 영역 -->
    <!-- 23.12.04 game-box-area div 추가, game-box-top로 클래스 변경 -->
    <div class="game-box-area">
      <div class="game-box-top">
        마음이 어질고 자애로움 마음이 어질고 자애로움

        <button class="q-sound">질문 듣기</button>

        <p class="q-time">58초</p>
      </div>
    </div>
    <!-- //질문 영역 -->

    <!-- 2x2 -->
    <!--
    <div class="answer-word-area"> 
    -->
      <!-- 정답영역 -->
      <!--
      <div class="word-box-area">
        <p class="word-box2">?</p>
        <p class="word-box2">?</p>
      </div>
      -->
      <!-- //정답영역 -->

      <!-- 정답에만 data-name 값이 동일하게 들어가야 함 -->
      <!--
      <div class="draw-line-word">
        <div class="ui-draw-line" data-id="word-line">
          <div class="n1">
            <div class="ui-draw-dot" data-name="1">
              <span>인</span>
            </div>
          </div>
          <div class="n2">
            <div class="ui-draw-dot" data-name="">
              <span>존</span>
            </div>
          </div>
          <div class="n3">
            <div class="ui-draw-dot" data-name="">
              <span>엄</span>
            </div>
          </div>
          <div class="n4">
            <div class="ui-draw-dot" data-name="1">
              <span>자</span>
            </div>
          </div>
        </div>
      </div>
      -->
    <!--
    </div>
    -->
    <!-- //2x2 -->

    <!-- 23.12.28 3x3 추가 -->
    <!-- 3x3 -->
    <div class="answer-word-area word-3x3">
      <!-- 정답영역 -->
      <div class="word-box-area">
        <p class="word-box2">?</p>
        <p class="word-box2">?</p>
        <p class="word-box2">?</p>
      </div>
      <!-- //정답영역 -->

      <!-- 정답에만 data-name 값이 동일하게 들어가야 함 -->
      <div class="draw-line-word">
        <div class="ui-draw-line" data-id="word-line">
          <div class="n1">
            <div class="ui-draw-dot" data-name="1">
              <span>인</span>
            </div>
          </div>
          <div class="n2">
            <div class="ui-draw-dot" data-name="">
              <span>존</span>
            </div>
          </div>
          <div class="n3">
            <div class="ui-draw-dot" data-name="">
              <span>엄</span>
            </div>
          </div>
          <div class="n4">
            <div class="ui-draw-dot" data-name="">
              <span>자</span>
            </div>
          </div>
          <div class="n5">
            <div class="ui-draw-dot" data-name="1">
              <span>노</span>
            </div>
          </div>
          <div class="n6">
            <div class="ui-draw-dot" data-name="">
              <span>기</span>
            </div>
          </div>
          <div class="n7">
            <div class="ui-draw-dot" data-name="">
              <span>자</span>
            </div>
          </div>
          <div class="n8">
            <div class="ui-draw-dot" data-name="">
              <span>노</span>
            </div>
          </div>
          <div class="n9">
            <div class="ui-draw-dot" data-name="1">
              <span>기</span>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- //3x3 -->

    <!-- 문제 페이징 -->
    <div class="q-paging-area">
      <a href="#" class="on">1</a>
      <a href="#">2</a>
      <a href="#">3</a>
      <a href="#">4</a>
      <a href="#">5</a>
      <a href="#">6</a>
    </div>
    <!-- //문제 페이징 -->
    <!-- 240426 : 정답확인 버튼 추가 -->
    <div class="q-drag-check-btn">
      <button type="button">정답확인</button>
    </div>
    <!-- //240426 : 정답확인 버튼 추가 -->
  </div>

  <script>
    class DrawLine {
        constructor(opt) {
          this.id = opt.id;
          this.wrap = document.querySelector('.ui-draw-line[data-id="' + this.id + '"]');
          this.dots = this.wrap.querySelectorAll('.ui-draw-dot');
          this.wrap_t = this.wrap.getBoundingClientRect().top;
          this.wrap_l = this.wrap.getBoundingClientRect().left;
          this.wrap_w = this.wrap.offsetWidth;
          this.wrap_h = this.wrap.offsetHeight;
          this.answer = opt.answer;
          this.callback = opt.callback;
          this.answer_n = 0;
          this.currentDot = null;
          this.init();
        }
        init() {
          this.wrap.insertAdjacentHTML('beforeend', '<svg></svg>');
          for (let item of this.dots) {
            const _dot_info = item.getBoundingClientRect();
            const _dot_name = item.dataset.name;
            const _dot_w = item.offsetWidth / 2;
            const _dot_h = item.offsetHeight / 2;
            item.dataset.x = _dot_info.left + _dot_w - this.wrap_l;
            item.dataset.y = _dot_info.top + _dot_h - this.wrap_t;
          }
          const touchBuffer = 0; // Adjust the buffer size as needed
          const actStart = (e) => {
            const el_svg = this.wrap.querySelector('svg');
            const el_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            el_line.setAttribute('x1', 0);
            el_line.setAttribute('x2', 0);
            el_line.setAttribute('y1', 0);
            el_line.setAttribute('y2', 0);
            el_line.setAttribute('data-state', 'ing');
            el_svg.appendChild(el_line);
            this.wrap_t = this.wrap.getBoundingClientRect().top;
            this.wrap_l = this.wrap.getBoundingClientRect().left;
            this.wrap_w = this.wrap.offsetWidth;
            this.wrap_h = this.wrap.offsetHeight;
            const win_y = window.scrollY;
            const win_x = window.scrollX;
            const el_dot = e.currentTarget;
            this.currentDot = el_dot;
            this.currentDot.classList.add('active')
            const dot_info = el_dot.getBoundingClientRect();
            const dot_name = el_dot.dataset.name;
            const dot_w = el_dot.offsetWidth / 2 + touchBuffer;
            const dot_h = el_dot.offsetHeight / 2 + touchBuffer;
            const s_x = !!e.clientX ? e.clientX : e.targetTouches[0].clientX;
            const s_y = !!e.clientY ? e.clientY : e.targetTouches[0].clientY;
            let dot_data = [];
            let _x;
            let _y;
            const startX = dot_info.left + dot_w - this.wrap_l;
            const startY = dot_info.top + dot_h - this.wrap_t;
            el_line.setAttribute('x1', startX);
            el_line.setAttribute('y1', startY);
            el_line.setAttribute('x2', startX);
            el_line.setAttribute('y2', startY);
            for (let item of this.dots) {
              item.dataset.state = 'none';
            }
            const actEnd = (e) => {
              const v_x = _x;
              const v_y = _y;
              el_line.dataset.state = 'complete';
              const uiDrawDots = document.querySelectorAll('.ui-draw-dot');
              for (let dot of uiDrawDots) {
                dot.classList.remove('active');
              }
              let is_answer = false;
              for (let item of this.dots) {
                item.dataset.state = '';
                const i_x = Number(item.dataset.x);
                const i_y = Number(item.dataset.y);
                if (
                  v_x <= i_x + dot_w &&
                  v_x >= i_x - dot_w &&
                  v_y <= i_y + dot_h &&
                  v_y >= i_y - dot_h &&
                  item !== el_dot
                ) {
                  if (item.dataset.name === dot_name && item.dataset.name !== '') {
                    is_answer = true;
                    el_dot.dataset.complete = true;
                    item.dataset.complete = true;
                    this.answer_n = this.answer_n + 1;
                    break;
                  }
                }
              }
              // 모든 연결된 점의 data-name 값을 가져와서 중복을 제거합니다.
              const connectedDotNames = [...document.querySelectorAll('.ui-draw-dot[data-complete="true"]')]
                .map(dot => dot.dataset.name)
                .filter(name => name !== "");

              // 중복을 제거한 data-name 배열의 길이를 확인하여 모든 점의 data-name이 같은지 검사합니다.
              const isAllNamesEqual = connectedDotNames.length > 0 &&
                connectedDotNames.every(name => name === connectedDotNames[0]);

              if (isAllNamesEqual) {
                console.log('정답입니다!');
              } else {
                console.log('아직 정답을 다 그리지 않았습니다.');
              }
              if (!is_answer) {
                console.log('바르게 움직여 주세요.'); // 오답일 때 메시지 출력을 주석 처리
                el_line.remove();
              }
              for (let item of this.dots) {
                item.dataset.state = '';
              }
              this.wrap.removeEventListener('mousemove', actMove);
              this.wrap.removeEventListener('mouseup', actEnd);
              this.wrap.removeEventListener('touchmove', actMove);
              this.wrap.removeEventListener('touchend', actEnd);
              this.callback({
                sum: this.answer,
                value: this.answer_n,
                name: dot_name,
                state: is_answer,
              });
              // this.checkComplete();
            };
            const actMove = (e) => {
              _x = !!e.clientX ? e.clientX - this.wrap.offsetLeft : e.targetTouches[0].clientX- this.wrap.offsetLeft;
              _y = !!e.clientY ? e.clientY - this.wrap.offsetTop : e.targetTouches[0].clientY - this.wrap.offsetTop;
              
              el_line.setAttribute('x2', _x);
              el_line.setAttribute('y2', _y);
              // 현재 위치에서 가장 가까운 점 찾기
              let nearestDot = null;
              let minDistance = Number.MAX_SAFE_INTEGER;
              for (let item of this.dots) {
                const i_x = Number(item.dataset.x);
                const i_y = Number(item.dataset.y);
                const distance = Math.sqrt(Math.pow(_x - i_x, 2) + Math.pow(_y - i_y, 2));

                if (distance < minDistance && distance <= dot_w) {
                  minDistance = distance;
                  nearestDot = item;
                  el_line.setAttribute('x2', i_x);
                  el_line.setAttribute('y2', i_y);
                }
              }
                
              // 현재 위치에서 가장 가까운 점에 "active" 클래스 추가
              for (let item of this.dots) {
                if (item === nearestDot) {
                  item.classList.add('active');
                } else {
                  item.classList.remove('active');
                }
              }
              
              // 활성화된 요소 중심 좌표를 찾아서 라인을 스냅
              let activeDot = null;
              for (let item of this.dots) {
                if (item.classList.contains('active')) {
                  activeDot = item;
                  break;
                }
              }

              if (activeDot) {
                const centerX = Number(activeDot.dataset.x);
                const centerY = Number(activeDot.dataset.y);
                el_line.setAttribute('x2', centerX);
                el_line.setAttribute('y2', centerY);
              } else {
                // 활성화된 요소가 없으면 현재 마우스 위치를 사용
                el_line.setAttribute('x2', _x);
                el_line.setAttribute('y2', _y);
              }
            };
            //event
            this.wrap.addEventListener('mousemove', actMove);
            this.wrap.addEventListener('mouseup', actEnd);
            this.wrap.addEventListener('touchmove', actMove);
            this.wrap.addEventListener('touchend', actEnd);
          };
          for (let item of this.dots) {
            item.addEventListener('mousedown', actStart);
            item.addEventListener('touchstart', actStart);
          }
        }
        // checkComplete() {
        //   if (this.answer_n === this.answer) {
        //       console.log('정답입니다!'); // 정답 콘솔 메시지 출력
        //   } else {
        //       console.log('아직 정답을 다 그리지 않았습니다.'); // 정답이 아닐 때 메시지 출력
        //   }
        // }
    }
    const drawline = new DrawLine({
      id: 'word-line',
      answer: 1,
      callback: (v) => {
        console.log(v);
      },
    });
  </script>
</body>
</html>