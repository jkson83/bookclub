<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
          box-sizing: border-box;
        }
        body {
            margin: 0;
            overflow: hidden;
        }
      
        .ui-draw {
            overflow: hidden;
            margin: 0 auto;
            position: relative;
            width: 100%;
            height: 100vh;
            background-color: #f2f2f2;
            display: flex;
            align-content: space-between;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 10px 0;
        }
        
        .ui-draw svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .ui-draw line {
            stroke: #333;
            stroke-width: 20;
            stroke-linecap: round;
            pointer-events: none;
            stroke-dasharray: 30px;
            opacity: .3;
        }
        
        .ui-draw line[data-state=ing] {
            stroke: #333;
        }
        
        .ui-draw line[data-state=complete] {
            stroke: #f00;
            stroke-dasharray: 0;
        }
        
        .ui-draw-dot {
            position: relative;
            width: 100%;
            height: calc((100vh / 3) - 10px);
            border-radius: 5px;
            border:1px solid #000;
        }
          
        .ui-draw-dot.active {
          background-color: #ccc
        }

        .ui-draw-dot[data-complete="true"],
        .ui-draw-dot[data-state="none"] {
            pointer-events: none;
        }
        [class^="n"]{
          width:calc((100% / 3) - 10px);
        }
        /* .n1 { top: 100px; left: 50px }
        .n2 { top: 400px; right: 50px }
        .n3 { top: 300px; left: 50px }
        .n4 { top: 100px; right: 50px }
        .n5 { top: 400px; left: 50px }
        .n6 { top: 200px; right: 50px } */
    </style>
</head>
<body>
<div>
    <div class="ui-draw" data-id="test">
        <div class="n1">
          <div class="ui-draw-dot" data-name="1">
            <span>111</span>
          </div>
        </div>
        <div class="n2">
          <div class="ui-draw-dot" data-name="">
            <span>333</span>
          </div>
        </div>
        <div class="n5">
          <div class="ui-draw-dot" data-name="">
            <span>333</span>
          </div>
        </div>
        <div class="n3">
          <div class="ui-draw-dot" data-name="">
            <span>333</span>
          </div>
        </div>
        <div class="n6">
          <div class="ui-draw-dot" data-name="1">
            <span>111</span>
          </div>
        </div>
        <div class="n6">
          <div class="ui-draw-dot" data-name="">
            <span>333</span>
          </div>
        </div>
        <div class="n6">
          <div class="ui-draw-dot" data-name="">
            <span>333</span>
          </div>
        </div>
        <div class="n6">
          <div class="ui-draw-dot" data-name="">
            <span>333</span>
          </div>
        </div>
        <div class="n6">
          <div class="ui-draw-dot" data-name="1">
            <span>111</span>
          </div>
        </div>
    </div>
</div>
    <script>
        class DrawLine {
            constructor(opt) {
                this.id = opt.id;
                this.wrap = document.querySelector('.ui-draw[data-id="' + this.id + '"]');
                this.dots = this.wrap.querySelectorAll('.ui-draw-dot');
                this.wrap_t = this.wrap.getBoundingClientRect().top;
                this.wrap_l = this.wrap.getBoundingClientRect().left;
                this.wrap_w = this.wrap.offsetWidth;
                this.wrap_h = this.wrap.offsetHeight;
                this.answer = opt.answer;
                this.callback = opt.callback;
                this.answer_n = 0;
                this.currentDot = null;
                this.init();
            }
            init() {
                this.wrap.insertAdjacentHTML('beforeend', '<svg></svg>');
                for (let item of this.dots) {
                    const _dot_info = item.getBoundingClientRect();
                    const _dot_name = item.dataset.name;
                    const _dot_w = item.offsetWidth / 2;
                    const _dot_h = item.offsetHeight / 2;
                    item.dataset.x = _dot_info.left + _dot_w - this.wrap_l;
                    item.dataset.y = _dot_info.top + _dot_h - this.wrap_t;
                }
                const touchBuffer = 0; // Adjust the buffer size as needed
                const actStart = (e) => {
                    const el_svg = this.wrap.querySelector('svg');
                    const el_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    el_line.setAttribute('x1', 0);
                    el_line.setAttribute('x2', 0);
                    el_line.setAttribute('y1', 0);
                    el_line.setAttribute('y2', 0);
                    el_line.setAttribute('data-state', 'ing');
                    el_svg.appendChild(el_line);
                    this.wrap_t = this.wrap.getBoundingClientRect().top;
                    this.wrap_l = this.wrap.getBoundingClientRect().left;
                    this.wrap_w = this.wrap.offsetWidth;
                    this.wrap_h = this.wrap.offsetHeight;
                    const win_y = window.scrollY;
                    const win_x = window.scrollX;
                    const el_dot = e.currentTarget;
                    this.currentDot = el_dot;
                    this.currentDot.classList.add('active')
                    const dot_info = el_dot.getBoundingClientRect();
                    const dot_name = el_dot.dataset.name;
                    const dot_w = el_dot.offsetWidth / 2 + touchBuffer;
                    const dot_h = el_dot.offsetHeight / 2 + touchBuffer;
                    const s_x = !!e.clientX ? e.clientX : e.targetTouches[0].clientX;
                    const s_y = !!e.clientY ? e.clientY : e.targetTouches[0].clientY;
                    let dot_data = [];
                    let _x;
                    let _y;
                    const startX = dot_info.left + dot_w - this.wrap_l;
                    const startY = dot_info.top + dot_h - this.wrap_t;
                    el_line.setAttribute('x1', startX);
                    el_line.setAttribute('y1', startY);
                    el_line.setAttribute('x2', startX);
                    el_line.setAttribute('y2', startY);
                    for (let item of this.dots) {
                        item.dataset.state = 'none';
                    }
                    const actEnd = (e) => {
                        const v_x = _x;
                        const v_y = _y;
                        el_line.dataset.state = 'complete';
                        const uiDrawDots = document.querySelectorAll('.ui-draw-dot');
                        for (let dot of uiDrawDots) {
                            dot.classList.remove('active');
                        }
                        let is_answer = false;
                        for (let item of this.dots) {
                            item.dataset.state = '';
                            const i_x = Number(item.dataset.x);
                            const i_y = Number(item.dataset.y);
                            if (
                                v_x <= i_x + dot_w &&
                                v_x >= i_x - dot_w &&
                                v_y <= i_y + dot_h &&
                                v_y >= i_y - dot_h &&
                                item !== el_dot
                            ) {
                                if (item.dataset.name === dot_name && item.dataset.name !== '') {
                                    is_answer = true;
                                    el_dot.dataset.complete = true;
                                    item.dataset.complete = true;
                                    this.answer_n = this.answer_n + 1;
                                    break;
                                }
                            }
                        }
        // 모든 연결된 점의 data-name 값을 가져와서 중복을 제거합니다.
        const connectedDotNames = [...document.querySelectorAll('.ui-draw-dot[data-complete="true"]')]
            .map(dot => dot.dataset.name)
            .filter(name => name !== "");

        // 중복을 제거한 data-name 배열의 길이를 확인하여 모든 점의 data-name이 같은지 검사합니다.
        const isAllNamesEqual = connectedDotNames.length > 0 &&
            connectedDotNames.every(name => name === connectedDotNames[0]);

        if (isAllNamesEqual) {
            console.log('정답입니다!');
        } else {
            console.log('아직 정답을 다 그리지 않았습니다.');
        }
                        if (!is_answer) {
                            console.log('바르게 움직여 주세요.'); // 오답일 때 메시지 출력을 주석 처리
                            el_line.remove();
                        }
                        for (let item of this.dots) {
                            item.dataset.state = '';
                        }
                        this.wrap.removeEventListener('mousemove', actMove);
                        this.wrap.removeEventListener('mouseup', actEnd);
                        this.wrap.removeEventListener('touchmove', actMove);
                        this.wrap.removeEventListener('touchend', actEnd);
                        this.callback({
                            sum: this.answer,
                            value: this.answer_n,
                            name: dot_name,
                            state: is_answer,
                          });
                          // this.checkComplete();
                    };
                    const actMove = (e) => {
                      _x = !!e.clientX ? e.clientX : e.targetTouches[0].clientX;
                      _y = !!e.clientY ? e.clientY : e.targetTouches[0].clientY;

                      el_line.setAttribute('x2', _x);
                      el_line.setAttribute('y2', _y);
                      // 현재 위치에서 가장 가까운 점 찾기
                      let nearestDot = null;
                      let minDistance = Number.MAX_SAFE_INTEGER;
                      for (let item of this.dots) {
                          const i_x = Number(item.dataset.x);
                          const i_y = Number(item.dataset.y);
                          const distance = Math.sqrt(Math.pow(_x - i_x, 2) + Math.pow(_y - i_y, 2));
                          if (distance < minDistance && distance <= dot_w) {
                              minDistance = distance;
                              nearestDot = item;
                              el_line.setAttribute('x2', i_x);
                              el_line.setAttribute('y2', i_y);
                          }
                      }
                      
                      // 현재 위치에서 가장 가까운 점에 "active" 클래스 추가
                      for (let item of this.dots) {
                          if (item === nearestDot) {
                              item.classList.add('active');
                          } else {
                              item.classList.remove('active');
                          }
                      }
                      
                      // 활성화된 요소 중심 좌표를 찾아서 라인을 스냅
                      let activeDot = null;
                      for (let item of this.dots) {
                          if (item.classList.contains('active')) {
                              activeDot = item;
                              break;
                          }
                      }

                      if (activeDot) {
                          const centerX = Number(activeDot.dataset.x);
                          const centerY = Number(activeDot.dataset.y);
                          el_line.setAttribute('x2', centerX);
                          el_line.setAttribute('y2', centerY);
                      } else {
                          // 활성화된 요소가 없으면 현재 마우스 위치를 사용
                          el_line.setAttribute('x2', _x);
                          el_line.setAttribute('y2', _y);
                      }
                    };
                    //event
                    this.wrap.addEventListener('mousemove', actMove);
                    this.wrap.addEventListener('mouseup', actEnd);
                    this.wrap.addEventListener('touchmove', actMove);
                    this.wrap.addEventListener('touchend', actEnd);
                };
                for (let item of this.dots) {
                    item.addEventListener('mousedown', actStart);
                    item.addEventListener('touchstart', actStart);
                }
            }
            // checkComplete() {
            //   if (this.answer_n === this.answer) {
            //       console.log('정답입니다!'); // 정답 콘솔 메시지 출력
            //   } else {
            //       console.log('아직 정답을 다 그리지 않았습니다.'); // 정답이 아닐 때 메시지 출력
            //   }
            // }
        }
        const drawline = new DrawLine({
            id: 'test',
            answer: 1,
            callback: (v) => {
                console.log(v);
            },
        });
    </script>
</body>
</html>
