<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
      
        .ui-draw {
            overflow: hidden;
            margin: 0 auto;
            position: relative;
            width: 100%;
            height: 100vh;
            background-color: #f2f2f2;
        }
        
        .ui-draw svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        
        .ui-draw line {
            stroke: #ccc;
            stroke-width: 1;
            stroke-linecap: round;
            pointer-events: none;
            stroke-dasharray: 10px;
        }
        
        .ui-draw line[data-state=ing] {
            stroke: #ccc;
        }
        
        .ui-draw line[data-state=complete] {
            stroke: #000;
            stroke-dasharray: 0;
        }
        
        .ui-draw-dot {
            position: relative;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: black;
        }
          
        .ui-draw-dot.active {
          background-color: red;
        }
        .ui-draw-dot:before {
            content: '';
            position: absolute;
            top:50%;
            left:50%;
            width:50px;
            height:50px;
            margin:-25px 0 0 -25px;
        }
        .ui-draw-dot.active:after {
          content: '';
          position: absolute;
          top:-3px;
          right:-3px;
          bottom:-3px;
          left:-3px;
          border-radius:50%;
          border:3px solid blue;
        }
        .ui-draw-dot[data-complete="true"],
        .ui-draw-dot[data-state="none"] {
            pointer-events: none;
        }
        [class^="n"]{
          display: flex;
          position: absolute;
          z-index: 1;
          transform: translate(-50%, -50%); /* 중심 정렬을 위해 추가 */
          gap:10px;
          align-items: center;
          user-select: none;
        }
        [class^="n"]:nth-child(2n){
          flex-flow: row-reverse;
        }
        .n1 { top: 100px; left: 50px }
        .n2 { top: 400px; right: 50px }
        .n3 { top: 300px; left: 50px }
        .n4 { top: 100px; right: 50px }
        .n5 { top: 400px; left: 50px }
        .n6 { top: 200px; right: 50px }
    </style>
</head>
<body>
    <div class="ui-draw" data-id="test">
        <div class="n1">
          <span>111</span>
          <div class="ui-draw-dot" data-name="1"></div>
        </div>
        <div class="n2">
          <span>111</span>
          <div class="ui-draw-dot" data-name="1"></div>
        </div>
        <div class="n3">
          <span>222</span>
          <div class="ui-draw-dot" data-name="2"></div>
        </div>
        <div class="n4">
          <span>222</span>
          <div class="ui-draw-dot" data-name="2"></div>
        </div>
        <div class="n5">
          <span>333</span>
          <div class="ui-draw-dot" data-name="3"></div>
        </div>
        <div class="n6">
          <span>333</span>
          <div class="ui-draw-dot" data-name="3"></div>
        </div>
    </div>
    <script>
        class DrawLine {
            constructor(opt) {
                this.id = opt.id;
                this.wrap = document.querySelector('.ui-draw[data-id="' + this.id + '"]');
                this.dots = this.wrap.querySelectorAll('.ui-draw-dot');
                this.wrap_t = this.wrap.getBoundingClientRect().top;
                this.wrap_l = this.wrap.getBoundingClientRect().left;
                this.wrap_w = this.wrap.offsetWidth;
                this.wrap_h = this.wrap.offsetHeight;
                this.answer = opt.answer;
                this.callback = opt.callback;
                this.answer_n = 0;
                this.currentDot = null;
                this.init();
            }
            init() {
                this.wrap.insertAdjacentHTML('beforeend', '<svg></svg>');
                for (let item of this.dots) {
                    const _dot_info = item.getBoundingClientRect();
                    const _dot_name = item.dataset.name;
                    const _dot_w = item.offsetWidth / 2;
                    const _dot_h = item.offsetHeight / 2;
                    item.dataset.x = _dot_info.left + _dot_w - this.wrap_l;
                    item.dataset.y = _dot_info.top + _dot_h - this.wrap_t;
                }
                const touchBuffer = 0; // Adjust the buffer size as needed
                const actStart = (e) => {
                    const el_svg = this.wrap.querySelector('svg');
                    const el_line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    el_line.setAttribute('x1', 0);
                    el_line.setAttribute('x2', 0);
                    el_line.setAttribute('y1', 0);
                    el_line.setAttribute('y2', 0);
                    el_line.setAttribute('data-state', 'ing');
                    el_svg.appendChild(el_line);
                    this.wrap_t = this.wrap.getBoundingClientRect().top;
                    this.wrap_l = this.wrap.getBoundingClientRect().left;
                    this.wrap_w = this.wrap.offsetWidth;
                    this.wrap_h = this.wrap.offsetHeight;
                    const win_y = window.scrollY;
                    const win_x = window.scrollX;
                    const el_dot = e.currentTarget;
                    this.currentDot = el_dot;
                    this.currentDot.classList.add('active')
                    const dot_info = el_dot.getBoundingClientRect();
                    const dot_name = el_dot.dataset.name;
                    const dot_w = el_dot.offsetWidth / 2 + touchBuffer;
                    const dot_h = el_dot.offsetHeight / 2 + touchBuffer;
                    const s_x = !!e.clientX ? e.clientX : e.targetTouches[0].clientX;
                    const s_y = !!e.clientY ? e.clientY : e.targetTouches[0].clientY;
                    let dot_data = [];
                    let _x;
                    let _y;
                    const startX = dot_info.left + dot_w - this.wrap_l;
                    const startY = dot_info.top + dot_h - this.wrap_t;
                    el_line.setAttribute('x1', startX);
                    el_line.setAttribute('y1', startY);
                    el_line.setAttribute('x2', startX);
                    el_line.setAttribute('y2', startY);
                    for (let item of this.dots) {
                        item.dataset.state = 'none';
                    }
                    const actEnd = (e) => {
                        const v_x = _x;
                        const v_y = _y;
                        el_line.dataset.state = 'complete';
                        const uiDrawDots = document.querySelectorAll('.ui-draw-dot');
                        for (let dot of uiDrawDots) {
                            dot.classList.remove('active');
                        }
                        let is_answer = false;
                        for (let item of this.dots) {
                            item.dataset.state = '';
                            const i_x = Number(item.dataset.x);
                            const i_y = Number(item.dataset.y);
                            if (
                                v_x <= i_x + dot_w &&
                                v_x >= i_x - dot_w &&
                                v_y <= i_y + dot_h &&
                                v_y >= i_y - dot_h &&
                                item !== el_dot
                            ) {
                                if (item.dataset.name === dot_name) {
                                    is_answer = true;
                                    el_dot.dataset.complete = true;
                                    item.dataset.complete = true;
                                    this.answer_n = this.answer_n + 1;
                                    break;
                                }
                            }
                        }
                        if (!is_answer) {
                            console.log('바르게 움직여 주세요.'); // 오답일 때 메시지 출력을 주석 처리
                            el_line.remove();
                        }
                        for (let item of this.dots) {
                            item.dataset.state = '';
                        }
                        this.wrap.removeEventListener('mousemove', actMove);
                        this.wrap.removeEventListener('mouseup', actEnd);
                        this.wrap.removeEventListener('touchmove', actMove);
                        this.wrap.removeEventListener('touchend', actEnd);
                        this.callback({
                            sum: this.answer,
                            value: this.answer_n,
                            name: dot_name,
                            state: is_answer,
                        });
                    };
                    const actMove = (e) => {
                        _x = !!e.clientX ? e.clientX : e.targetTouches[0].clientX;
                        _y = !!e.clientY ? e.clientY : e.targetTouches[0].clientY;
                        el_line.setAttribute('x2', _x);
                        el_line.setAttribute('y2', _y);    
                        // 현재 위치에서 가장 가까운 점 찾기
                        let nearestDot = null;
                        let minDistance = Number.MAX_SAFE_INTEGER;
                        for (let item of this.dots) {
                            const i_x = Number(item.dataset.x);
                            const i_y = Number(item.dataset.y);
                            const distance = Math.sqrt(Math.pow(_x - i_x, 2) + Math.pow(_y - i_y, 2));
                            if (distance < minDistance && distance <= dot_w) {
                                minDistance = distance;
                                nearestDot = item;
                                el_line.setAttribute('x2', i_x);
                                el_line.setAttribute('y2', i_y);
                            }
                        }
                        
                        // 현재 위치에서 가장 가까운 점에 "active" 클래스 추가
                        for (let item of this.dots) {
                            if (item === nearestDot) {
                                item.classList.add('active');
                            } else {
                                item.classList.remove('active');
                            }
                        }
                        // 활성화된 요소 중심 좌표를 찾아서 라인을 스냅
                        let activeDot = null;
                        for (let item of this.dots) {
                            if (item.classList.contains('active')) {
                                activeDot = item;
                                break;
                            }
                        }
                        if (activeDot) {
                            const centerX = Number(activeDot.dataset.x);
                            const centerY = Number(activeDot.dataset.y);
                            el_line.setAttribute('x2', centerX);
                            el_line.setAttribute('y2', centerY);
                        } else {
                            // 활성화된 요소가 없으면 현재 마우스 위치를 사용
                            el_line.setAttribute('x2', _x);
                            el_line.setAttribute('y2', _y);
                        }
                    };
                    //event
                    this.wrap.addEventListener('mousemove', actMove);
                    this.wrap.addEventListener('mouseup', actEnd);
                    this.wrap.addEventListener('touchmove', actMove);
                    this.wrap.addEventListener('touchend', actEnd);
                };
                for (let item of this.dots) {
                    item.addEventListener('mousedown', actStart);
                    item.addEventListener('touchstart', actStart);
                }
            }
            checkComplete() {
                const completeDots = Array.from(this.dots).filter((dot) => dot.dataset.complete === 'true');
                if (completeDots.length === this.answer * 2) {
                    console.log('모두 정답입니다.');
                }
            }
        }
        const drawline = new DrawLine({
            id: 'test',
            answer: 3,
            callback: (v) => {
                console.log(v);
                drawline.checkComplete();
            },
        });
    </script>
</body>
</html>
